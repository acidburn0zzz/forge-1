#!/usr/bin/env python3

# Copyright (C) 2019 Internet Systems Consortium, Inc. ("ISC")
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
"""Forge - testing tool for Kea and ISC DHCP."""

from __future__ import print_function
import os
import time
import string
import logging
import argparse
import textwrap
import functools
import subprocess
import configparser
from urllib.parse import urljoin

log = logging.getLogger()

FORGE_INI = 'forge.ini'

SRV4_ADDR = "192.168.50.252"
CLNT4_ADDR = "192.168.50.2"
CLNT4_ADDR_2 = "192.168.51.2"
SRV_IPV6_ADDR_GLOBAL = "3000::1000"
MGMT_ADDRESS = "172.28.0.31"
MGMT_ADDRESS_2 = "172.28.0.32"
MGMT_ADDRESS_3 = "172.28.0.33"
DNS4_ADDR = SRV4_ADDR
DNS6_ADDR = "2001:db8:0:f101::1"
IFACE = "enp0s9"
SERVER_IFACE = "enp0s9"
INSTALL_METHOD = "make"

INIT_ALL = """
LOGLEVEL = "info"
IFACE = "{IFACE}"
#IFACE = "eth2"
SERVER_IFACE = "{SERVER_IFACE}"
#SERVER_IFACE = "eth2"
DNS4_ADDR = "{DNS4_ADDR}"
DNS6_ADDR = "{DNS6_ADDR}"
SOFTWARE_UNDER_TEST = "kea4_server", "bind9_server",
SOFTWARE_INSTALL_PATH = "/usr/local"
DB_TYPE = "memfile"
SHOW_PACKETS_FROM = "both"
SRV4_ADDR = "{SRV4_ADDR}"
REL4_ADDR = "0.0.0.0"
GIADDR4 = "192.168.50.3"
CIADDR = "192.168.50.3"
CLI_LINK_LOCAL = ""
copylist = []
removelist = []
OUTPUT_WAIT_INTERVAL = 1
OUTPUT_WAIT_MAX_INTERVALS = 2
PACKET_WAIT_INTERVAL = 1
SRV_IPV6_ADDR_GLOBAL = "{SRV_IPV6_ADDR_GLOBAL}"
SRV_IPV6_ADDR_LINK_LOCAL = "fe80::a00:27ff:fedf:63bc"
HISTORY = True
TCPDUMP = False
TCPDUMP_PATH = ""
SAVE_CONFIG_FILE = True
AUTO_ARCHIVE = False
SLEEP_TIME_1 = 1  # wait after starting remote server
SLEEP_TIME_2 = 2  # wait after all others commands
MGMT_ADDRESS = "{MGMT_ADDRESS}"
MGMT_ADDRESS_2 = "{MGMT_ADDRESS_2}"
MGMT_ADDRESS_3 = "{MGMT_ADDRESS_3}"
MGMT_USERNAME = "vagrant"
MGMT_PASSWORD = "vagrant"
SAVE_LOGS = True
BIND_LOG_TYPE = "ERROR"
BIND_LOG_LVL = 0
BIND_MODULE = "*"
SAVE_LEASES = True
DNS_IFACE = "enp0s3"
DNS_PORT = 53
DNS_SERVER_INSTALL_PATH = "/usr/local/sbin/"
DNS_DATA_PATH = "/home/wlodek/dns/"
ISC_DHCP_LOG_FACILITY = "local7"
ISC_DHCP_LOG_FILE = "/var/log/forge_dhcpd.log"
DB_NAME = "keadb"
DB_USER = "keauser"
DB_PASSWD = "keapass"
DB_HOST = ""
FABRIC_PTY = ""
INSTALL_METHOD = "{INSTALL_METHOD}"
"""


CONFIG_FIELDS = ['kea-dirs']


def _load_config():
    config = configparser.ConfigParser()
    if os.path.exists(FORGE_INI):
        config.read(FORGE_INI)
    if not config.has_section('Forge'):
        config.add_section('Forge')
    return config


def _save_config(config):
    with open(FORGE_INI, 'w') as configfile:
        config.write(configfile)


def update_config(name, value):
    if name not in CONFIG_FIELDS:
        raise Exception('Unknown config field %s' % name)
    if name == 'kea-dirs':
        value = os.path.abspath(value)
        if not os.path.exists(value):
            raise Exception('Folder %s does not exists.' % value)
        if not os.path.isdir(value):
            raise Exception('%s is not a directory.' % value)

    print('Setting %s to %s' % (name, value))
    cfg = _load_config()
    cfg.set('Forge', name, value)
    _save_config(cfg)


def show_config(name):
    cfg = _load_config()
    if name:
        if name not in CONFIG_FIELDS:
            raise Exception('Unknown config field %s' % name)
        print('%s = %s' % (name, cfg['Forge'][name]))
    else:
        for k, v in cfg['Forge'].items():
            print('%s = %s' % (k , v))


class ExecutionError(Exception):
    """Exception thrown when execution encountered an error."""
    pass


def execute(cmd, timeout=60, cwd=None, env=None, raise_error=True, dry_run=False, log_file_path=None,
            quiet=False, check_times=False, capture=False, interactive=False, attempts=1,
            sleep_time_after_attempt=None):
    """Execute a command in shell.

    :param str cmd: a command to be executed
    :param int timeout: timeout in number of seconds, after that time the command is terminated
                        but only if check_times is True
    :param str cwd: current working directory for the command
    :param dict env: dictionary with environment variables
    :param bool raise_error: if False then in case of error exception is not raised,
                             default: True ie exception is raise
    :param bool dry_run: if True then the command is not executed
    :param str log_file_path: if provided then all traces from the command are stored in indicated file
    :param bool quiet: if True then the command's traces are not printed to stdout
    :param bool check_times: if True then timeout is taken into account
    :param bool capture: if True then the command's traces are captured and returned by the function
    :param bool interactive: if True then stdin and stdout are not redirected, traces handling is disabled,
                             used for e.g. SSH
    :param int attemts: number of attempts to run the command if it fails
    :param int sleep_time_after_attempt: number of seconds to sleep before taking next attempt
    """
    log.info('>>>>> Executing %s in %s', cmd, cwd if cwd else os.getcwd())
    if not check_times:
        timeout = None
    if dry_run:
        return 0

    if 'sudo' in cmd and env:
        # if sudo is used and env is overridden then to preserve env add -E to sudo
        cmd = cmd.replace('sudo', 'sudo -E')

    if log_file_path:
        log_file = open(log_file_path, "wb")

    for attempt in range(attempts):
        if interactive:
            p = subprocess.Popen(cmd, cwd=cwd, env=env, shell=True)
            exitcode = p.wait()

        else:
            p = subprocess.Popen(cmd, cwd=cwd, env=env, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

            if capture:
                output = ''
            t0 = time.time()
            t1 = time.time()
            # repeat until process is running or timeout not occured
            while p.poll() is None and (timeout is None or t1 - t0 < timeout):
                line = p.stdout.readline()
                if line:
                    line_decoded = line.decode(errors='ignore').rstrip() + '\r'
                    if not quiet:
                        print(line_decoded)
                    if capture:
                        output += line_decoded
                    if log_file_path:
                        log_file.write(line)
                t1 = time.time()

            # If no exitcode yet, ie. process is still running then it means that timeout occured.
            # In such case terminate the process and raise an exception.
            if p.poll() is None:
                # kill using sudo to be able to kill other sudo commands
                execute('sudo kill -s TERM %s' % p.pid)
                time.sleep(5)
                # if still running, kill harder
                if p.poll() is None:
                    execute('sudo kill -s KILL %s' % p.pid)
                msg = "Execution timeout, %d > %d seconds elapsed (start: %d, stop %d), cmd: '%s'"
                msg = msg % (t1 - t0, timeout, t0, t1, cmd)
                raise ExecutionError(msg)
            exitcode = p.returncode

        if exitcode == 0:
            break
        elif attempt < attempts - 1:
            txt = 'command failed, retry, attempt %d/%d' % (attempt, attempts)
            if log_file_path:
                txt_to_file = '\n\n[FORGE] %s\n\n\n' % txt
                log_file.write(txt_to_file.encode('ascii'))
            log.info(txt)
            if sleep_time_after_attempt:
                time.sleep(sleep_time_after_attempt)

    if log_file_path:
        log_file.close()

    if exitcode != 0 and raise_error:
        raise ExecutionError("The command return non-zero exitcode %s, cmd: '%s'" % (exitcode, cmd))

    if capture:
        return exitcode, output
    return exitcode


def set_init_all(args):
    # generate init_all.py
    my_vars = globals()
    if hasattr(args, 'native') and args.native:
        my_vars['INSTALL_METHOD'] = 'native'
    txt = INIT_ALL.format(**my_vars)

    path = os.path.abspath('tests/init_all.py')
    with open(path, 'w') as f:
        f.write(txt)
    print('Generated %s.' % path)


def get_vagrant_dir(args):
    vagrant_dir = os.path.join('vagrant',
                               'lxc' if args.lxc else 'vbox',
                               args.sid if args.sid else 'default')
    vagrant_dir = os.path.abspath(vagrant_dir)
    return vagrant_dir


def ensure_lxc_bridges(args):
    mgmt_brg = 'lxcfgmgmt' + args.sid if args.sid else 'lxcfgmgmt'
    traffic1_brg = 'lxcfgtrf1' + args.sid if args.sid else 'lxcfgtrf1'
    traffic2_brg = 'lxcfgtrf2' + args.sid if args.sid else 'lxcfgtrf2'

    for bridge in [mgmt_brg, traffic1_brg, traffic2_brg]:
        execute('sudo brctl addbr %s' % bridge, raise_error=False)  # TODO: add detection if already exists
        execute('sudo ip link set dev %s up' % bridge)


def setup(args):
    # load config
    cfg = _load_config()

    set_init_all(args)

    if args.lxc:
        vagrant_tpl = 'vagrant/Vagrantfile.lxc.in'
    else:
        vagrant_tpl = 'vagrant/Vagrantfile.in'

    client_name = 'forge-client-' + args.sid if args.sid else 'forge-client'
    server1_name = 'forge-srv1-u1804-' + args.sid if args.sid else 'forge-srv1-u1804'
    server2_name = 'forge-srv2-u1804-' + args.sid if args.sid else 'forge-srv2-u1804'
    mgmt_brg = 'lxcfgmgmt' + args.sid if args.sid else 'lxcfgmgmt'
    traffic1_brg = 'lxcfgtrf1' + args.sid if args.sid else 'lxcfgtrf1'
    traffic2_brg = 'lxcfgtrf2' + args.sid if args.sid else 'lxcfgtrf2'

    # generate Vagrantfile
    with open(vagrant_tpl, 'r') as f_in:
        txt = f_in.read()
    tpl = string.Template(txt)
    txt = tpl.safe_substitute(KEA_DIRS=cfg['Forge']['kea-dirs'],
                              MGMT_ADDRESS=MGMT_ADDRESS,
                              SRV4_ADDR=SRV4_ADDR,
                              CLNT4_ADDR=CLNT4_ADDR,
                              CLNT4_ADDR_2=CLNT4_ADDR_2,
                              SRV_IPV6_ADDR_GLOBAL=SRV_IPV6_ADDR_GLOBAL,
                              IFACE=IFACE,
                              SERVER_IFACE=SERVER_IFACE,
                              CLIENT_NAME=client_name,
                              SERVER1_NAME=server1_name,
                              SERVER2_NAME=server2_name,
                              MGMT_BRG=mgmt_brg,
                              TRAFFIC1_BRG=traffic1_brg,
                              TRAFFIC2_BRG=traffic2_brg)
    vagrant_dir = get_vagrant_dir(args)
    if not os.path.exists(vagrant_dir):
        os.makedirs(vagrant_dir)
    vagrant_file = os.path.join(vagrant_dir, 'Vagrantfile')
    with open(vagrant_file, 'w') as f_out:
        f_out.write(txt)
    print('Generated %s.' % vagrant_file)

    if args.command == 'setup':
        # destroy VMs via Vagrant
        execute('vagrant destroy -f', cwd=vagrant_dir)

        # in case of LXC prepare bridges
        if args.lxc:
            ensure_lxc_bridges(args)

        # create and start VMs via Vagrant
        execute('vagrant up', cwd=vagrant_dir)
    elif args.command == 'refresh':
        # reload and reprovision VMs via Vagrant if requested
        reload_ = args.reload
        provision = args.provision
        if not reload_ and not provision:
            reload_ = True
            provision = True
        if reload_:
            execute('vagrant reload', cwd=vagrant_dir)
        if provision:
            execute('vagrant provision', cwd=vagrant_dir)


def install_kea(args):
    ensure_lxc_bridges(args)

    vagrant_dir = get_vagrant_dir(args)
    execute('vagrant up', cwd=vagrant_dir, raise_error=False)

    if args.version:
        _install_kea_native(args)
    else:
        _install_kea_make(args)


def _install_kea_native(args):
    vagrant_dir = get_vagrant_dir(args)
    server1_name = 'forge-srv1-u1804-' + args.sid if args.sid else 'forge-srv1-u1804'
    cmd_tpl = 'vagrant ssh ' + server1_name + ' -c "%s"'

    # copy hammer into vm and prepare system
    execute('rm -rf hammer.py')
    execute('wget https://gitlab.isc.org/isc-projects/kea/raw/master/hammer.py')
    execute('chmod a+x hammer.py')
    # cmd = 'vagrant upload ../../../hammer.py %s' % server1_name
    cmd = 'vagrant upload hammer.py %s' % server1_name
    execute(cmd, cwd=vagrant_dir)

    cmd = cmd_tpl % './hammer.py prepare-system -p local -w mysql,pgsql,radius,forge'
    execute(cmd, cwd=vagrant_dir)

    # prepare pkg source repo in vm
    repository_url = 'https://packages.isc.org'
    repo_name = 'kea-%s-%s-%s' % ('1.6', 'ubuntu', '18.04')
    repo_url = urljoin(repository_url, 'repository')
    repo_url += '/%s-ci/' % repo_name

    subcmd = "echo 'deb %s kea main' | sudo tee /etc/apt/sources.list.d/isc.list" % repo_url
    cmd = cmd_tpl % subcmd
    execute(cmd, cwd=vagrant_dir)
    key_url = "%s/repository/repo-keys/repo-key.gpg" % repository_url
    subcmd = 'wget -qO- %s | sudo apt-key add -' % key_url
    cmd = cmd_tpl % subcmd
    execute(cmd, cwd=vagrant_dir)

    cmd = cmd_tpl % 'sudo apt update'
    execute(cmd, cwd=vagrant_dir)

    pkgs = ["isc-kea-admin",
            "isc-kea-common",
            "isc-kea-ctrl-agent",
            "isc-kea-dev",
            "isc-kea-dhcp4-server",
            "isc-kea-dhcp6-server",
            "isc-kea-dhcp-ddns-server",
            "isc-kea-doc",
            "python3-isc-kea-connector"]

    sfx = '=' + args.version
    pkgs = [p + sfx for p in pkgs]
    pkgs = " ".join(pkgs)

    cmd = cmd_tpl % 'sudo apt install -y %s' % pkgs
    env = os.environ.copy()
    env['DEBIAN_FRONTEND'] = 'noninteractive'
    execute(cmd, cwd=vagrant_dir, env=env)


def _install_kea_make(args):
    server1_name = 'forge-srv1-u1804-' + args.sid if args.sid else 'forge-srv1-u1804'
    cmd = 'vagrant ssh ' + server1_name + ' -c "%s"'
    cfg = _load_config()
    kea_dirs = cfg['Forge']['kea-dirs']
    local_kea_path = os.path.join(kea_dirs, args.path)
    if args.path == '':
        print('Path to Kea folder is empty. Give one of these:')
        for d in sorted(os.listdir(kea_dirs)):
            p = os.path.join(kea_dirs, d)
            if os.path.isdir(p):
                print('  %s' % d)
        exit(1)
    if not os.path.exists(local_kea_path):
        raise Exception('Folder %s does not exists.' % local_kea_path)
    if not os.path.isdir(local_kea_path):
        raise Exception('Folder %s is not a directory.' % local_kea_path)

    remote_path = os.path.join('/kea-dirs', args.path)
    subcmd = 'cd %s && ./hammer.py %s -p local -x unittest docs perfdhcp -w forge mysql pgsql cql radius shell'

    vagrant_dir = get_vagrant_dir(args)

    subcmd1 = subcmd % (remote_path, 'prepare-system')
    cmd1 = cmd % subcmd1
    execute(cmd1, cwd=vagrant_dir)

    subcmd2 = subcmd % (remote_path, 'build')
    cmd2 = cmd % subcmd2
    execute(cmd2, cwd=vagrant_dir)


def test(args, params):
    set_init_all(args)

    ensure_lxc_bridges(args)

    vagrant_dir = get_vagrant_dir(args)
    execute('vagrant up', cwd=vagrant_dir, raise_error=False)

    params = ' '.join(params)
    print('Test params: %s' % params)
    client_name = 'forge-client-' + args.sid if args.sid else 'forge-client'
    cmd = 'vagrant ssh ' + client_name + ' -c "%s"'
    subcmd = 'cd /forge/; sudo ~/venv/bin/pytest ' + params
    cmd %= subcmd
    execute(cmd, cwd=vagrant_dir, raise_error=False)


def clean(args):
    vagrant_dir = get_vagrant_dir(args)
    execute('vagrant destroy -f', cwd=vagrant_dir)
    for path in ['tests/init_all.py', os.path.join(vagrant_dir, 'Vagrantfile')]:
        path = os.path.abspath(path)
        if os.path.exists(path):
            os.unlink(path)
            print('Deleted %s.' % path)


def parse_args():
    """Parse arguments."""
    # used lambda to change args order and able to substitute width
    fl = functools.partial(lambda w, t: textwrap.fill(t, w), 80)
    description = [
        "Forge - testing tool for Kea and ISC DHCP.\n",
        "Basic steps for running Forge are as follows:\n"
        "1) first configure forge itself\n\n"
        "   ./forge config kea-dirs /path/to/kea/repos\n\n"
        "2) create VMs\n\n"
        "   ./forge setup\n\n"
        "3) install Kea in one of VMs\n\n"
        "   ./forge install-kea kea-subdir\n\n"
        "4) run indicated tests, parameters are directly passed to pytest\n\n"
        "   ./forge test -m v4\n"
    ]
    description = "\n".join(description)
    main_parser = argparse.ArgumentParser(description=description,
                                          formatter_class=argparse.RawDescriptionHelpFormatter)

    main_parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose mode.')
    main_parser.add_argument('-q', '--quiet', action='store_true', help='Enable quiet mode.')
    main_parser.add_argument('--lxc', action='store_true', default=False,
                             help='Use LXC instead of VirtualBox.')
    main_parser.add_argument('--sid', default=None,
                             help='ID of setup. If more setups needed in parallel then run with specific ID.')

    subparsers = main_parser.add_subparsers(
        dest='command',
        title="Forge commands",
        description=fl("The following commands are provided by Forge. "
                       "To get more information about particular command invoke: "
                       "./forge <command> -h.\n"))

    parser = subparsers.add_parser('config',
                                   help="Set config parameter in config file ie. forge.ini.")
    parser.add_argument('name', nargs='?', default=None,
                        help='Name of parameter.')
    parser.add_argument('value', nargs='?', default=None,
                        help='Value for indicated parameter.')
    parser = subparsers.add_parser('setup',
                                   help="Create VMs where testing happens.")
    parser = subparsers.add_parser('refresh',
                                   help="Refresh VMs ie. restart and re-provision")
    parser.add_argument('--reload', action='store_true',
                        help='Reload only.')
    parser.add_argument('--provision', action='store_true',
                        help='Re-provision only.')
    parser = subparsers.add_parser('install-kea',
                                   help="Install Kea into VM from indicated repository.")
    parser.add_argument('path', default='', nargs='?', help='Sub-path to the repository.')
    parser.add_argument('--version', help='Version of packages.')
    parser = subparsers.add_parser('test',
                                   help="Run tests. Parameters are passed directly to pytest.")
    parser.add_argument('--native', action='store_true', default=False,
                        help='Use native packages for testing')
    parser = subparsers.add_parser('clean',
                                   help="Destroy VMs")

    #args = main_parser.parse_args()
    args, rest = main_parser.parse_known_args()
    return args, rest, main_parser


def main():
    """Main function - parse args and invoke proper command."""
    args, rest, parser = parse_args()

    # prepare logging
    level = logging.INFO
    if args.verbose:
        level = logging.DEBUG
    fmt = '[FORGE]  %(asctime)-15s  %(message)s'
    logging.basicConfig(format=fmt, level=level)

    # dispatch command
    if args.command == 'config':
        if args.value is not None:
            update_config(args.name, args.value)
        else:
            show_config(args.name)

    elif args.command == 'setup':
        setup(args)

    elif args.command == "refresh":
        setup(args)

    elif args.command == "install-kea":
        install_kea(args)

    elif args.command == "test":
        test(args, rest)

    elif args.command == "clean":
        clean(args)

    else:
        parser.print_help()


if __name__ == '__main__':
    main()
